<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nxalyzer - Dependency Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a2e;
        color: #eee;
        overflow: hidden;
      }
      #controls {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 100;
        background: #16213e;
        padding: 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        min-width: 200px;
      }
      #controls h2 {
        margin-bottom: 12px;
        font-size: 14px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      #file-input {
        display: none;
      }
      #upload-btn {
        background: #0f3460;
        color: #fff;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
        width: 100%;
      }
      #upload-btn:hover {
        background: #1a4a7a;
      }
      .control-group {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid #334;
      }
      .control-group label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 13px;
        margin-bottom: 8px;
      }
      .control-group input[type="checkbox"] {
        margin-right: 8px;
      }
      .control-group input[type="range"] {
        width: 100%;
        margin-top: 4px;
      }
      .slider-label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #888;
        margin-top: 4px;
      }
      .filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        font-size: 13px;
      }
      .filter-actions {
        display: flex;
        gap: 4px;
      }
      .filter-btn {
        background: #0f3460;
        color: #aaa;
        border: none;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
      }
      .filter-btn:hover {
        background: #1a4a7a;
        color: #fff;
      }
      .filter-item {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 12px;
        margin-bottom: 6px;
        padding: 4px 6px;
        border-radius: 4px;
        transition: background 0.15s;
      }
      .filter-item:hover {
        background: rgba(255, 255, 255, 0.05);
      }
      .filter-item input {
        margin-right: 8px;
      }
      .filter-color {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
      }
      #stats {
        margin-top: 12px;
        font-size: 12px;
        color: #888;
      }
      #tooltip {
        position: fixed;
        background: #16213e;
        padding: 12px;
        border-radius: 6px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 200;
      }
      #tooltip .name {
        font-weight: bold;
        font-size: 14px;
        margin-bottom: 4px;
      }
      #tooltip .type {
        color: #888;
        margin-bottom: 4px;
      }
      #tooltip .cluster {
        color: #06d6a0;
        margin-bottom: 4px;
      }
      #tooltip .file {
        color: #666;
        word-break: break-all;
      }
      #legend {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: #16213e;
        padding: 16px;
        border-radius: 8px;
        font-size: 12px;
      }
      #legend h3 {
        font-size: 11px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
      }
      #legend h3:not(:first-child) {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid #334;
      }
      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 6px;
      }
      .legend-item:last-child {
        margin-bottom: 0;
      }
      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }
      .legend-color.cluster {
        border-radius: 3px;
        opacity: 0.6;
      }
      svg {
        display: block;
      }
      .link {
        stroke: #334;
        stroke-opacity: 0.6;
      }
      .node {
        cursor: pointer;
      }
      .node:hover {
        filter: brightness(1.3);
      }
      .label {
        font-size: 10px;
        fill: #aaa;
        pointer-events: none;
      }
      .cluster-label {
        font-size: 24px;
        font-weight: bold;
        fill: #fff;
        opacity: 0.15;
        pointer-events: none;
        text-anchor: middle;
      }
      .cluster-hull {
        fill-opacity: 0.08;
        stroke-opacity: 0.3;
        stroke-width: 2;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h2>Load Graph</h2>
      <input type="file" id="file-input" accept=".json" />
      <button id="upload-btn">Select graph.json</button>
      <div id="stats"></div>

      <div class="control-group">
        <label>
          <input type="checkbox" id="cluster-toggle" checked />
          Enable Clustering
        </label>
        <label>
          <input type="checkbox" id="labels-toggle" checked />
          Show Labels
        </label>
        <label>
          <input type="checkbox" id="hulls-toggle" checked />
          Show Cluster Hulls
        </label>
      </div>

      <div class="control-group">
        <label for="cluster-strength">Cluster Strength</label>
        <input
          type="range"
          id="cluster-strength"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
        <div class="slider-label"><span>Loose</span><span>Tight</span></div>
      </div>

      <div class="control-group">
        <div class="filter-header">
          <span>Filter by Type</span>
          <div class="filter-actions">
            <button id="select-all-types" class="filter-btn">All</button>
            <button id="select-none-types" class="filter-btn">None</button>
          </div>
        </div>
        <label class="filter-item">
          <input
            type="checkbox"
            class="type-filter"
            data-type="class"
            checked
          />
          <span class="filter-color" style="background: #e94560"></span>
          Class
        </label>
        <label class="filter-item">
          <input
            type="checkbox"
            class="type-filter"
            data-type="interface"
            checked
          />
          <span class="filter-color" style="background: #0f3460"></span>
          Interface
        </label>
        <label class="filter-item">
          <input type="checkbox" class="type-filter" data-type="type" checked />
          <span class="filter-color" style="background: #00b4d8"></span>
          Type
        </label>
        <label class="filter-item">
          <input
            type="checkbox"
            class="type-filter"
            data-type="function"
            checked
          />
          <span class="filter-color" style="background: #06d6a0"></span>
          Function
        </label>
        <label class="filter-item">
          <input type="checkbox" class="type-filter" data-type="enum" checked />
          <span class="filter-color" style="background: #ffd166"></span>
          Enum
        </label>
        <label class="filter-item">
          <input
            type="checkbox"
            class="type-filter"
            data-type="const"
            checked
          />
          <span class="filter-color" style="background: #9d4edd"></span>
          Const
        </label>
        <label class="filter-item">
          <input
            type="checkbox"
            class="type-filter"
            data-type="unknown"
            checked
          />
          <span class="filter-color" style="background: #666"></span>
          Unknown
        </label>
      </div>
    </div>

    <div id="tooltip">
      <div class="name"></div>
      <div class="type"></div>
      <div class="cluster"></div>
      <div class="file"></div>
    </div>

    <div id="legend">
      <h3>Entity Type</h3>
      <div class="legend-item">
        <div class="legend-color" style="background: #e94560"></div>
        Class
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #0f3460"></div>
        Interface
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00b4d8"></div>
        Type
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #06d6a0"></div>
        Function
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ffd166"></div>
        Enum
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #9d4edd"></div>
        Const
      </div>

      <h3>Cluster</h3>
      <div class="legend-item">
        <div class="legend-color cluster" style="background: #e94560"></div>
        Web App
      </div>
      <div class="legend-item">
        <div class="legend-color cluster" style="background: #06d6a0"></div>
        Mobile App
      </div>
      <div class="legend-item">
        <div class="legend-color cluster" style="background: #00b4d8"></div>
        Libs
      </div>
      <div class="legend-item">
        <div class="legend-color cluster" style="background: #666"></div>
        Other
      </div>
    </div>

    <svg id="graph"></svg>

    <script>
      const typeColors = {
        class: "#e94560",
        interface: "#0f3460",
        type: "#00b4d8",
        function: "#06d6a0",
        enum: "#ffd166",
        const: "#9d4edd",
        unknown: "#666",
      };

      const clusterColors = {
        web: "#e94560",
        mobile: "#06d6a0",
        libs: "#00b4d8",
        other: "#666",
      };

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Cluster center positions
      const clusterCenters = {
        web: { x: width * 0.25, y: height * 0.4 },
        mobile: { x: width * 0.75, y: height * 0.4 },
        libs: { x: width * 0.5, y: height * 0.7 },
        other: { x: width * 0.5, y: height * 0.2 },
      };

      const svg = d3
        .select("#graph")
        .attr("width", width)
        .attr("height", height);

      const g = svg.append("g");

      // Layers for proper z-ordering
      const hullLayer = g.append("g").attr("class", "hull-layer");
      const linkLayer = g.append("g").attr("class", "link-layer");
      const nodeLayer = g.append("g").attr("class", "node-layer");
      const labelLayer = g.append("g").attr("class", "label-layer");
      const clusterLabelLayer = g
        .append("g")
        .attr("class", "cluster-label-layer");

      // Zoom behavior
      const zoom = d3
        .zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });

      svg.call(zoom);

      // Arrow marker for directed edges
      svg
        .append("defs")
        .append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "-0 -5 10 10")
        .attr("refX", 20)
        .attr("refY", 0)
        .attr("orient", "auto")
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .append("path")
        .attr("d", "M 0,-5 L 10,0 L 0,5")
        .attr("fill", "#334");

      const tooltip = d3.select("#tooltip");

      // Determine cluster from file path
      function getCluster(filePath) {
        if (filePath.includes("apps/web") || filePath.includes("apps\\web"))
          return "web";
        if (
          filePath.includes("apps/mobile") ||
          filePath.includes("apps\\mobile")
        )
          return "mobile";
        if (filePath.includes("libs") || filePath.includes("libs\\"))
          return "libs";
        return "other";
      }

      function getClusterLabel(cluster) {
        const labels = {
          web: "Web App",
          mobile: "Mobile App",
          libs: "Libs",
          other: "Other",
        };
        return labels[cluster] || cluster;
      }

      // Convex hull for cluster visualization
      function computeHull(points) {
        if (points.length < 3) return null;
        return d3.polygonHull(points);
      }

      let simulation = null;
      let currentData = null;
      let rawData = null; // Store original unfiltered data

      function getSelectedTypes() {
        const checkboxes = document.querySelectorAll(".type-filter:checked");
        return Array.from(checkboxes).map((cb) => cb.dataset.type);
      }

      function filterData(data) {
        const selectedTypes = getSelectedTypes();
        const filteredNodes = data.nodes.filter((n) =>
          selectedTypes.includes(n.type),
        );
        const nodeIds = new Set(filteredNodes.map((n) => n.id));
        const filteredLinks = data.links.filter((l) => {
          const sourceId =
            typeof l.source === "object" ? l.source.id : l.source;
          const targetId =
            typeof l.target === "object" ? l.target.id : l.target;
          return nodeIds.has(sourceId) && nodeIds.has(targetId);
        });
        return {
          nodes: filteredNodes,
          links: filteredLinks.map((l) => ({
            source: typeof l.source === "object" ? l.source.id : l.source,
            target: typeof l.target === "object" ? l.target.id : l.target,
          })),
        };
      }

      function renderGraph(data) {
        currentData = data;

        // Clear previous graph
        hullLayer.selectAll("*").remove();
        linkLayer.selectAll("*").remove();
        nodeLayer.selectAll("*").remove();
        labelLayer.selectAll("*").remove();
        clusterLabelLayer.selectAll("*").remove();

        // Assign clusters to nodes
        data.nodes.forEach((node) => {
          node.cluster = getCluster(node.file);
        });

        // Update stats
        const clusterCounts = {};
        data.nodes.forEach((n) => {
          clusterCounts[n.cluster] = (clusterCounts[n.cluster] || 0) + 1;
        });
        const totalNodes = rawData ? rawData.nodes.length : data.nodes.length;
        const totalLinks = rawData ? rawData.links.length : data.links.length;
        const statsText =
          rawData && data.nodes.length !== totalNodes
            ? `${data.nodes.length}/${totalNodes} nodes, ${data.links.length}/${totalLinks} edges`
            : `${data.nodes.length} nodes, ${data.links.length} edges`;
        document.getElementById("stats").textContent = statsText;

        const clusteringEnabled =
          document.getElementById("cluster-toggle").checked;
        const clusterStrength = parseFloat(
          document.getElementById("cluster-strength").value,
        );

        // Create simulation
        simulation = d3
          .forceSimulation(data.nodes)
          .force(
            "link",
            d3
              .forceLink(data.links)
              .id((d) => d.id)
              .distance(80),
          )
          .force("charge", d3.forceManyBody().strength(-200))
          .force("collision", d3.forceCollide().radius(20));

        if (clusteringEnabled) {
          simulation
            .force(
              "x",
              d3
                .forceX((d) => clusterCenters[d.cluster].x)
                .strength(clusterStrength),
            )
            .force(
              "y",
              d3
                .forceY((d) => clusterCenters[d.cluster].y)
                .strength(clusterStrength),
            );
        } else {
          simulation
            .force("x", d3.forceX(width / 2).strength(0.05))
            .force("y", d3.forceY(height / 2).strength(0.05));
        }

        // Create cluster labels
        const clusters = [...new Set(data.nodes.map((n) => n.cluster))];
        clusterLabelLayer
          .selectAll("text")
          .data(clusters)
          .join("text")
          .attr("class", "cluster-label")
          .attr("x", (d) => clusterCenters[d].x)
          .attr("y", (d) => clusterCenters[d].y)
          .text((d) => getClusterLabel(d).toUpperCase())
          .style("opacity", clusteringEnabled ? 0.15 : 0);

        // Create links
        const link = linkLayer
          .selectAll("line")
          .data(data.links)
          .join("line")
          .attr("class", "link")
          .attr("marker-end", "url(#arrowhead)");

        // Create nodes
        const node = nodeLayer
          .selectAll("circle")
          .data(data.nodes)
          .join("circle")
          .attr("class", "node")
          .attr("r", 8)
          .attr("fill", (d) => typeColors[d.type] || typeColors.unknown)
          .attr("stroke", (d) => clusterColors[d.cluster])
          .attr("stroke-width", 2)
          .call(drag(simulation));

        // Node hover events
        node
          .on("mouseover", (event, d) => {
            tooltip.style("opacity", 1);
            tooltip.select(".name").text(d.name);
            tooltip.select(".type").text(`Type: ${d.type}`);
            tooltip
              .select(".cluster")
              .text(`Cluster: ${getClusterLabel(d.cluster)}`);
            tooltip.select(".file").text(d.file);
          })
          .on("mousemove", (event) => {
            tooltip
              .style("left", event.pageX + 15 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", () => {
            tooltip.style("opacity", 0);
          });

        // Create labels
        const showLabels = document.getElementById("labels-toggle").checked;
        const label = labelLayer
          .selectAll("text")
          .data(data.nodes)
          .join("text")
          .attr("class", "label")
          .attr("dx", 12)
          .attr("dy", 4)
          .text((d) => d.name)
          .style("opacity", showLabels ? 1 : 0);

        // Cluster hulls
        const showHulls = document.getElementById("hulls-toggle").checked;

        // Update positions on tick
        simulation.on("tick", () => {
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);

          label.attr("x", (d) => d.x).attr("y", (d) => d.y);

          // Update cluster hulls
          if (showHulls && clusteringEnabled) {
            const hulls = clusters
              .map((cluster) => {
                const points = data.nodes
                  .filter((n) => n.cluster === cluster)
                  .map((n) => [n.x, n.y]);
                return { cluster, hull: computeHull(points) };
              })
              .filter((h) => h.hull);

            hullLayer
              .selectAll("path")
              .data(hulls, (d) => d.cluster)
              .join("path")
              .attr("class", "cluster-hull")
              .attr("d", (d) => `M${d.hull.join("L")}Z`)
              .attr("fill", (d) => clusterColors[d.cluster])
              .attr("stroke", (d) => clusterColors[d.cluster]);
          } else {
            hullLayer.selectAll("path").remove();
          }
        });
      }

      // Drag behavior
      function drag(simulation) {
        function dragstarted(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
        }

        function dragged(event) {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        }

        function dragended(event) {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
        }

        return d3
          .drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
      }

      // File upload handling
      const fileInput = document.getElementById("file-input");
      const uploadBtn = document.getElementById("upload-btn");

      uploadBtn.addEventListener("click", () => fileInput.click());

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            rawData = JSON.parse(e.target.result);
            const filteredData = filterData(rawData);
            renderGraph(filteredData);
          } catch (err) {
            alert("Error parsing JSON: " + err.message);
          }
        };
        reader.readAsText(file);
      });

      // Control event handlers
      document
        .getElementById("cluster-toggle")
        .addEventListener("change", () => {
          if (rawData) renderGraph(filterData(rawData));
        });

      document
        .getElementById("labels-toggle")
        .addEventListener("change", (e) => {
          labelLayer
            .selectAll("text")
            .style("opacity", e.target.checked ? 1 : 0);
        });

      document.getElementById("hulls-toggle").addEventListener("change", () => {
        if (rawData) renderGraph(filterData(rawData));
      });

      document
        .getElementById("cluster-strength")
        .addEventListener("input", () => {
          if (rawData) renderGraph(filterData(rawData));
        });

      // Type filter event handlers
      document.querySelectorAll(".type-filter").forEach((cb) => {
        cb.addEventListener("change", () => {
          if (rawData) renderGraph(filterData(rawData));
        });
      });

      document
        .getElementById("select-all-types")
        .addEventListener("click", () => {
          document
            .querySelectorAll(".type-filter")
            .forEach((cb) => (cb.checked = true));
          if (rawData) renderGraph(filterData(rawData));
        });

      document
        .getElementById("select-none-types")
        .addEventListener("click", () => {
          document
            .querySelectorAll(".type-filter")
            .forEach((cb) => (cb.checked = false));
          if (rawData) renderGraph(filterData(rawData));
        });

      // Handle window resize
      window.addEventListener("resize", () => {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;
        svg.attr("width", newWidth).attr("height", newHeight);

        // Update cluster centers
        clusterCenters.web.x = newWidth * 0.25;
        clusterCenters.web.y = newHeight * 0.4;
        clusterCenters.mobile.x = newWidth * 0.75;
        clusterCenters.mobile.y = newHeight * 0.4;
        clusterCenters.libs.x = newWidth * 0.5;
        clusterCenters.libs.y = newHeight * 0.7;
        clusterCenters.other.x = newWidth * 0.5;
        clusterCenters.other.y = newHeight * 0.2;

        if (rawData) renderGraph(filterData(rawData));
      });
    </script>
  </body>
</html>
